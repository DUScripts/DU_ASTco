{"slots":{"0":{"name":"slot1","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"screens={}\n\nfor e,f in pairs(unit)do \n    if type(f)==\"table\"and type(f.export)==\"table\"then\n        if f.getElementClass then\n            if f.getElementClass()==\"ScreenUnit\"then \n                screens[#screens+1]=f\n            elseif f.getElementClass()==\"CoreUnitDynamic\"then \n                core=f\n            end \n        end \n    end \nend\n\nif not next(screens) then\n    system.print(\"No screen found\")\n    unit.exit()\nend\n\nif core == nil then\n   system.print(\"No core found\")\n    unit.exit()\nend\n\n\n\nlocal json = require(\"dkjson\")\nshipMass = math.floor(core.getConstructMass()/1000) \ndata = json.encode(core.getConstructWorldPos())\n\n\nscreenContent = [[\n-----------------------------------------------------------------------------------\n-- Atlas Lua Screen\n--\n-- This screen provides an example of a stellar atlas based on screen rendering\n-- and the local atlas.lua library.\n-----------------------------------------------------------------------------------\n\n--# Local constants class and objects definition\nlocal atlas = require(\"atlas\")\nlocal json = require(\"dkjson\")\nlocal getTextWrapped = require(\"rslib\").getTextWrapped\nlocal vec3 = require(\"cpml/vec3\")\n\nlocal system = atlas[0]\nlocal rx,ry = getResolution()\n\n\n--# Local rendering preparation\n-- Create layers\nlocal rear = createLayer()\nlocal back = createLayer()\nlocal front = createLayer()\nlocal fore = createLayer()\n\n-- Load fonts\nlocal small = loadFont('Play',10)\nlocal smallBold = loadFont('Play-Bold',10)\nlocal normal = loadFont('Play',16)\nlocal normalBold = loadFont('Play-Bold',16)\nlocal medium = loadFont('Play',22)\nlocal mediumBold = loadFont('Play-Bold',22)\n\n\n---# Local functions definition\n--Returns the id of the images requested to load (prevent to load multiple time the same image)\nlocal images = {}\nlocal function loadImages(src)\n    for k,img in pairs(images) do\n        if k == src then return img end\n    end\n    images[src] = loadImage(src)\n    return images[src]\nend\n\n--Returns a concatenated string of the given table with the comma separator according to the language\nlocal function concatList(list,lng)\n    local out = {}\n    for i,v in pairs(list) do\n        out[i] = v[lng]\n    end\n    return table.concat(out,', ')\nend\n\n--Check if the given table t has the given entry u\nlocal function contains(t, u)\n    for i,v in pairs(t) do\n        if v == u then return true, i end\n    end\n    return false\nend\n\n--Used to set the view to a given stellar body id\nlocal function setView( planets, id)\n    local i = 0\n    \n    for k,b in pairs( planets) do\n        if b.systemId == 0 then\n            i = i+1\n            if b.id == id then\n                break\n            end\n        end\n    end\n    \n    if _mode == 1 then\n        _viewX = 470-(i*350)\n    else\n        _initShift = _viewX\n        _shift = 470-(i*350)\n        _time = 0\n    end\nend\n\nlocal function isThadesAsteroid(planet)\n    if planet.systemId == 3 and planet.id >= 400 then\n        return true\n    end\n    return false\nend\n\n\n--# Settings\n-- showCursor : Set at true to display a cursor\n-- _lang : Set here the default language (1: English, 2: French, 3: German)\n-- _mode : Set the view mode (1: system view, 2: local view)\n-- _select : Set the default selected stellar body (i.e. 2 for Alioth)\n\nlocal showCursor = false\n_lang = _lang or 1\n_mode = _mode or 1\n_select = _select or 1\n\n\n--# Localisation fields for language support\nlocal loc = {\n    description = {\"Description\", \"Description\", \"Beschreibung\"},\n    ores = {\"Ores\", \"Minerais\", \"Erze\"},\n    biosphere = {\"Biosphere\", \"Biosphere\", \"Biosphare\"},\n    habitability = {\"Habitability\", \"Habitabilite\", \"Bewohnbarkeit\"},\n    classification = {\"Classification\", \"Classification\", \"Klassifizierung\"},\n    satellites = {\"Satellites\", \"Satellites\", \"Satelliten\"},\n    distance = {\"Distance\", \"Distance\", \"Entfernung\"},\n    radius = {\"Radius\", \"Rayon\", \"Radius\"},\n    gravity = {\"Gravity\", \"Gravité\", \"Schwerkraft\"},\n    atmoThickness = {\"Atmo. Thickness\", \"Epaiss. atmosphère\", \"Atmospharendicke\"},\n    noSatellite = {\"This stellar body does not have satellites.\",\"Ce corps stellaire ne dispose pas de satellites.\",\"Dieser Sternkörper hat keine Satelliten.\"}\n}\n\n--localisation names for ore\nlocal _ores={\n    --T1 Ores\n    [\"299255727\"]={\"Coal\",\"Charbon\",\"Kohle\"},\n    [\"4234772167\"]={\"Hematite\",\"Hématite\",\"Hämatit\"},\n    [\"262147665\"]={\"Bauxite\",\"Bauxite\",\"Bauxit\"},\n    [\"3724036288\"]={\"Quartz\",\"Quartz\",\"Quarz\"},\n    --T2 Ores\n    [\"2289641763\"]={\"Malachite\",\"Malachite\",\"Malachit\"},\n    [\"3086347393\"]={\"Limestone\",\"Calcaire\",\"Kalkstein\"},\n    [\"343766315\"]={\"Natron\",\"Natron\",\"Soda\"},\n    [\"2029139010\"]={\"Chromite\",\"Chromite\",\"Chromit\"},\n    --T3 Ores\n    [\"1065079614\"]={\"Garnierite\",\"Garniérite\",\"Garnierit\"},\n    [\"3837858336\"]={\"Petalite\",\"Pétalite\",\"Petalit\"},\n    [\"4041459743\"]={\"Pyrite\",\"Pyrite\",\"Pyrit\"},\n    [\"1050500112\"]={\"Acanthite\",\"Acanthite\",\"Akanthit\"},\n    --T4 Ores\n    [\"1467310917\"]={\"Cryolite\",\"Cryolite\",\"Kryolith\"},\n    [\"3546085401\"]={\"Cobaltite\",\"Cobaltite\",\"Cobaltit\"},\n    [\"1866812055\"]={\"Gold nuggets\",\"Pépites d'or\",\"Goldnuggets\"},\n    [\"271971371\"]={\"Kolbeckite\",\"Kolbeckite\",\"Kolbeckit\"},\n    --T5 Ores\n    [\"789110817\"]={\"Columbite\",\"Columbite\",\"Columbit\"},\n    [\"3934774987\"]={\"Rhodonite\",\"Rhodonite\",\"Rhodonit\"},\n    [\"629636034\"]={\"Ilmenite\",\"Ilménite\",\"Ilmenit\"},\n    [\"2162350405\"]={\"Vanadinite\",\"Vanadinite\",\"Vanadinit\"}\n}\n\n--replacing atlas ores ID by Names\nfor ks,s in pairs(atlas) do\n    for k,planet in pairs(s) do\n        if planet.ores then\n            for i,ore_id in ipairs(planet.ores) do\n                if _ores[tostring(ore_id)] then\n                    atlas[ks][k].ores[i] = _ores[tostring(ore_id)] or tostring(ore_id)\n                end\n            end\n        end\n    end\nend\n\n--# Initialization\n-- Define default values on globals parameters\n_viewX = _viewX or 220\n_planets = _planets or {}\n_time = _time and _time+getDeltaTime() or 0\n_initShift, _shift = _initShift or 0, _shift or 0\n\nlocal input, dist = getInput(), 0\n\n-- Called only at the first frame\nif not _init then\n    if not system[_select] then\n        _select = 1\n    end\n    \n    for _,b in pairs(system) do\n        if b.systemId == 0 then\n            if b.satellites then\n                local moons = {}\n                for _,sat in ipairs(b.satellites) do\n                    if not isThadesAsteroid(system[sat]) then\n                        table.insert(moons, sat)\n                    end\n                end\n                b.satellites = moons\n                table.sort (b.satellites, function (b1, b2) return system[b1].positionInSystem < system[b1].positionInSystem end )\n            end\n            \n            _planets[#_planets+1] = b\n        end\n    end\n    table.sort (_planets, function (b1, b2) return b1.positionInSystem < b2.positionInSystem end )\n    \n    setView( _planets, _select)\n    _init = true\nend\n\nlocal planet = system[_select]\nlocal vignette = loadImages(planet.iconPath)\n\n-- If a position is sent to the screen, compute the distance between this position and the planet center\nlocal data = json.decode(input) or {}\nif data.pos then dist = vec3(data.pos) - vec3(planet.center) end\n\n--- Warp Cells - added by Krengus\ndist = vec3(json.decode(getInput())) - vec3(planet.center)\ndist = dist:len()\nlocal warpcells = math.floor(1056 * dist/200000 * 0.00025);\n\n--# Computation\nlocal mx, my = getCursor()\nlocal down, pressed = getCursorDown(), getCursorPressed()\n\n--Compute actions on mouse clicks\nif pressed then\n    for k=1,3 do\n        local lx = rx-84 + k*24\n        if (mx-lx)^2 + (my-13) < 20^2 then\n            _lang = k\n        end\n    end\n\n    if _mode==2 and (mx-256)^2 + (my-32)^2 < 24^2 then\n        _mode = 1\n    end\nend\n\nif my>ry-60 and mx>224 and down then\n    if _mode==1 then\n        _viewX = 220-((mx-224)/700)*4200 + (rx-224)/2\n    else\n        _mode = 1\n    end\nend\n\n--Slide animation when clicked on a planet\nif _mode == 2 then    \n    local t = _time/1\n    local sqt = t * t;\n    \n    if t >= 1 then\n        _viewX = _shift\n    else\n        -- Smooth animation equation\n        _viewX = _initShift + (sqt / (2.0 * (sqt - t) + 1.0))*(_shift-_initShift); \n    end\nend\n\n--Clamp the view shift\n_viewX = _viewX>220 and 220 or _viewX\n_viewX = _viewX<-3800 and -3800 or _viewX\n\n\n---# Rendering\n--Draw backgrounds\nsetBackgroundColor(5/255, 6/255, 10/255)\n\nsetNextFillColor( front, 15/255, 16/255, 20/255, 1)\naddBox( front, 0, 0, 224, ry)\n\nsetNextFillColor( back, 5/255, 6/255, 10/255, 1)\naddBox( back, 224, ry-60, rx-224, 60)\n\n-- Draw the cursor\nif showCursor then\n    setNextStrokeWidth( fore, 0.1)\n    setNextStrokeColor( fore, 1, 193/255, 32/255, 1)\n    setNextFillColor( fore, 0,0,0,0)\n    addCircle( fore, mx, my, 5)\n    setNextFillColor( fore, 1, 193/255, 32/255, 1)\n    addCircle( fore, mx, my, 1)\nend\n\n\n--- Main view\n-- Draw the main view sun glow, only if visible on the view\nif _viewX > 0 then\n    setNextStrokeWidth( rear, 0)\n    setNextStrokeColor( rear, 0, 0, 0, 0)\n    setNextShadow( rear, 200, 255/255, 120/255, 5/255, 0.85)\n    addBox( rear, _viewX-10, 0, 0, ry)\nend\n\nlocal bx,by = _viewX+300, ry/2\n\n\n-- Draw the thumbnail sun glow\nsetNextStrokeWidth( back, 0)\nsetNextStrokeColor( back, 0, 0, 0, 0)\nsetNextShadow( back, 45, 255/255, 120/255, 5/255, 0.75)\naddBox( back, 200, ry-35, 0, 10)\n\n\n--- Draw all planets\nfor i,body in pairs(_planets) do\n    -- For each planet load the icon from the atlas data\n    local img = loadImages(body.iconPath)\n    local hover = false\n    local r = body.radius/900\n    \n    -- Compute the thumbnail position\n    local mbx = 224+(i*350)/6\n\n    \n    if _mode==1 or (_mode == 2 and _select == body.id or (body.satellites and contains(body.satellites, _select))) then\n        \n        --Check the hover and click events in the rendering (exception made to avoid having to do the same loop in the computation part).\n        if (mx-bx)*(mx-bx) + (my-by)*(my-by) < (r+18)^2 then\n            hover = true\n            \n            -- If hovering over the planet and clicking, select the planet and define the view\n            if pressed then\n                _select = body.id\n                if _mode == 1 then\n                    _mode = 2\n                    setView( _planets, body.id)\n                end\n            end\n        end\n\n        --Draw the planet only if it is visible on the screen in order to optimize the rendering cost.\n        if bx > -r*1.5 and bx < rx+r*1.5 then\n            if hover then\n                setNextStrokeWidth( rear, 0.1)\n                setNextStrokeColor( rear, 1, 193/255, 32/255, 1)\n            end\n            setNextFillColor( rear, 0, 0, 0, 0)\n            addCircle( rear, bx, by, r+18)\n            \n            --Draw atmosphere if the stellar body has\n            if body.hasAtmosphere then\n                local atm = body.atmosphereRadius/900\n                \n                setNextStrokeWidth( rear, 0.1)\n                setNextStrokeColor( rear, 1, 1, 1, 0.03)\n                setNextFillColor( rear, 1, 1, 1, 0.025)\n                addCircle( rear, bx, by, atm)\n            end\n\n            --Draw back line\n            setNextStrokeWidth( rear, 0.1)\n            setNextStrokeColor( rear, 1, 1, 1, 0.25)\n            addLine( rear, bx, 0, bx, ry)\n\n            --Draw planet image\n            if body.id == 3 then\n                addImage( back, img, bx-(2*r)+8, by-(2*r)+14, 2*(2*r), 2*(2*r))\n            else\n                r = 1.025 * r\n                addImage( back, img, bx-r, by-r, 2*r, 2*r)\n            end\n            \n            --Draw satellites if in local view\n            if _mode == 2 then\n                if body.satellites then\n                    \n                    -- Compute satellite position\n                    local dsx = 0.5 * (rx-bx+r)/(#body.satellites+1)\n                    local sx, sy = bx + r + dsx, by\n                    \n                    -- For each satellite\n                    for j,sid in pairs(body.satellites) do                     \n                        \n                        -- Get id and load image\n                        hover = false\n                        local sat = system[sid]\n                        local satImg = loadImages(sat.iconPath)\n                        sr = sat.radius/1240\n                        \n                        -- Check if hovering it\n                        if (mx-sx)*(mx-sx) + (my-sy)*(my-sy) < (sr+18)^2 then\n                            hover = true\n                            if pressed then\n                                _select = sat.id\n                            end\n                        end\n\n                        -- Draw an highlight if hovered\n                        if hover then\n                            setNextStrokeWidth( rear, 0.1)\n                            setNextStrokeColor( rear, 1, 193/255, 32/255, 1)\n                        end\n                        setNextFillColor( rear, 0, 0, 0, 0)\n                        addCircle( rear, sx, sy, sr+18)\n\n                        -- Draw an atmosphere if it has one\n                        if sat.hasAtmosphere then\n                            atm = sat.atmosphereRadius/1240\n\n                            setNextStrokeWidth( rear, 0.1)\n                            setNextStrokeColor( rear, 1, 1, 1, 0.03)\n                            setNextFillColor( rear, 1, 1, 1, 0.025)\n                            addCircle( rear, sx, sy, atm)\n                        end\n                        \n                        -- Draw the satellite image\n                        addImage( back, satImg, sx-sr, sy-sr, 2*sr, 2*sr)\n\n                        setNextStrokeWidth( rear, 0.1)\n                        setNextStrokeColor( rear, 1, 1, 1, 0.25)\n                        addLine( rear, sx, sy + (sr+10)*(-1)^j, sx, sy + (sr+38)*(-1)^j)\n\n                        -- Draw its name\n                        setNextTextAlign( back, AlignH_Center, AlignV_Middle)\n                        addText( back, normal, sat.name[_lang], sx, sy + (sr+48)*(-1)^j)\n                        \n                        sx = sx + sr + dsx\n                    end                \n                    \n                else\n                    --Otherwise, if the star body has no satellites, we display a message.\n                    setNextTextAlign( back, AlignH_Center, AlignV_Middle)\n                    addText( back, normal, loc.noSatellite[_lang], (rx+bx)/2, by)\n                end\n            end\n\n            --Draw the planet name\n            setNextTextAlign( back, AlignH_Center, AlignV_Baseline)\n            addText( back, medium, body.name[_lang], bx, by+r+38)\n        end\n    end\n\n\n    --Draw the thumbnail view\n    setNextStrokeWidth( back, 0.1)\n    setNextStrokeColor( back, 1, 1, 1, 0.25)\n    addLine( back, mbx, ry-60, mbx, ry)\n    addImage( front, img, mbx -r/8, ry-30 -r/8, 2*r/8, 2*r/8)\n\n    --If the local view, show the back button arrow\n    if _mode == 2 then\n        setNextStrokeColor( fore, 1, 193/255, 32/255, 1)\n        setNextStrokeWidth( fore, 1)\n        addLine( fore, 250, 32, 262, 44)\n        \n        setNextStrokeColor( fore, 1, 193/255, 32/255, 1)\n        setNextStrokeWidth( fore, 1)\n        addLine( fore, 250, 32, 262, 20)\n    end\n    \n    bx = bx +350\nend\n\n\n--Draw the minature view box\nsetNextFillColor( front, 1, 1, 1, 0.1)\naddBox( front, 224+(220-_viewX)/6, ry-60, (rx-224)/6, 60)\n\n--Draw the language selector\nlocal langs = {'EN', 'FR', 'GE'}\nfor k,l in pairs(langs) do\n    if _lang == k then\n        setNextFillColor( fore, 1, 193/255, 32/255, 1)\n    end\n    addText( fore, small, l .. (k<3 and '  |' or ''), rx-96 + k*24, 18)\nend\n\n\n--# Lateral View\n--Draw top part, name and image\naddText( front, medium, string.upper('| '..planet.name[_lang]), 18, 38)\n\nlocal y = 50\nsetNextFillColor( front, 10/255, 11/255, 15/255, 1)\naddBox( front, 0, y, 224, 120)\n\naddImage( fore, vignette, 112 - 50, y+10, 100, 100)\ny = y + 140\n\n\n--# Draw each information on the stellar body\n--- Description\naddText( front, smallBold, string.upper('| '.. loc.description[_lang]), 18, y)\n-- Use a getTextWrapped function from rslib library to wrap the text\nlocal _lines = getTextWrapped( small, planet.description and planet.description[_lang] or '-', 200)\nfor k,l in pairs(_lines) do\n    setNextFillColor( front, 1, 1, 1, 0.75)\n    addText( front, small, l, 18, y+2+k*10)\nend\ny = y + #_lines*10 + 16\n\n--- Ores on the planet\naddText( front, smallBold, string.upper('| '.. loc.ores[_lang]), 18, y)\nsetNextFillColor( front, 1, 1, 1, 0.75)\n-- Use a getTextWrapped function from rslib library to wrap the text\nlocal _lines = getTextWrapped( small, concatList(planet.ores, _lang), 200)\nfor k,l in pairs(_lines) do\n    setNextFillColor( front, 1, 1, 1, 0.75)\n    addText( front, small, l, 18, y+2+k*10)\nend\ny = y + #_lines*10 + 28\n\n--- Biosphere if it has\nif planet.biosphere then\n    addText( front, smallBold, string.upper('| '.. loc.biosphere[_lang]), 18, y)\n    setNextFillColor( front, 1, 1, 1, 0.75)\n    addText( front, small, planet.biosphere[_lang], 18, y+11)\n    y = y +26\nend\n\n--- Habitability class if it has\nif planet.habitability then\n    addText( front, smallBold, string.upper('| '.. loc.habitability[_lang]), 18, y)\n    setNextFillColor( front, 1, 1, 1, 0.75)\n    addText( front, small, planet.habitability[_lang], 18, y+11)\n    y = y +26\nend\n\n--- Classification class if it has\nif planet.classification then\n    addText( front, smallBold, string.upper('| '.. loc.classification[_lang]), 18, y)\n    setNextFillColor( front, 1, 1, 1, 0.75)\n    addText( front, small, planet.classification[_lang], 18, y+11)\n    y = y +26\nend\n\n--- Satellites count\naddText( front, smallBold, string.upper('| '.. loc.satellites[_lang]), 18, y)\nsetNextFillColor( front, 1, 1, 1, 0.75)\naddText( front, small, planet.satellites and #planet.satellites or 0, 18, y+11)\ny = y +38\n\n--- Distance to current location if a position is providen in input\nif dist ~= 0 then\n    addText( front, smallBold, string.upper('| '.. loc.distance[_lang]), 18, y)\n    setNextFillColor( front, 1, 1, 1, 0.75)\n    addText( front, small, string.format('%.2f km', dist/1000), 18, y+11)\n    y = y +26\nend\n\n--- Warp Cells calculation - added by Krengus\naddText( front, smallBold, string.upper('| '.. loc.distance[_lang]), 18, y)\nsetNextFillColor( front, 1, 1, 1, 0.75)\naddText( front, small, string.format('%.2f SU', dist/1000/200) .. '  -  Warp Cells: ' .. warpcells .. ' (]]..shipMass..[[ tons)', 18, y+11)\ny = y +26\n\n--- Radius data\naddText( front, smallBold, string.upper('| '.. loc.radius[_lang]), 18, y)\nsetNextFillColor( front, 1, 1, 1, 0.75)\naddText( front, small, string.format('%.2f km', planet.radius/1000), 18, y+11)\ny = y +26\n\n-- Gravity data at seat level\naddText( front, smallBold, string.upper('| '.. loc.gravity[_lang]), 18, y)\nsetNextFillColor( front, 1, 1, 1, 0.75)\naddText( front, small, string.format('%.2f m/s²', planet.gravity), 18, y+11)\ny = y +26\n\n-- If it has, add the atmospheric thickness data\nif planet.hasAtmosphere then\n    addText( front, smallBold, string.upper('| '.. loc.atmoThickness[_lang]), 18, y)\n    setNextFillColor( front, 1, 1, 1, 0.75)\n    addText( front, small, string.format('%.2f m', planet.atmosphereThickness), 18, y+11)\nend\n\n\n---# Request one run per frame\nrequestAnimationFrame(1)\n]]\n\n\nfor key, screen in pairs(screens) do -- updating screens\n    screen.activate()\n    screen.setScriptInput(data)\n    screen.setRenderScript(screenContent)\n    system.print(\"Atlas screen updated\")\nend\n\n\n\nunit.exit()\n\n","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"0"}],"methods":[],"events":[]}
