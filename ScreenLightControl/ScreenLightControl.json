{"slots": {"0": {"name": "slot1", "type": {"events": [], "methods": []}}, "1": {"name": "slot2", "type": {"events": [], "methods": []}}, "2": {"name": "slot3", "type": {"events": [], "methods": []}}, "3": {"name": "slot4", "type": {"events": [], "methods": []}}, "4": {"name": "slot5", "type": {"events": [], "methods": []}}, "5": {"name": "slot6", "type": {"events": [], "methods": []}}, "6": {"name": "slot7", "type": {"events": [], "methods": []}}, "7": {"name": "slot8", "type": {"events": [], "methods": []}}, "8": {"name": "slot9", "type": {"events": [], "methods": []}}, "9": {"name": "slot10", "type": {"events": [], "methods": []}}, "-1": {"name": "unit", "type": {"events": [], "methods": []}}, "-3": {"name": "player", "type": {"events": [], "methods": []}}, "-2": {"name": "construct", "type": {"events": [], "methods": []}}, "-4": {"name": "system", "type": {"events": [], "methods": []}}, "-5": {"name": "library", "type": {"events": [], "methods": []}}}, "handlers": [{"code": "Title = \"Front & Side Lights\" --export\nHide_Unit = true --export\n\nversion = 0.2\n\nscreens =  {}\nlights = {}\nicons = {}\n\nfor slot,element in pairs(unit)do -- checking elements in slots\n    if type(element)==\"table\"and type(element.export)==\"table\"then\n        if element.getClass then\n            if element.getClass()==\"ScreenUnit\"\n                or element.getClass()==\"ScreenSignUnit\" then\n                screens[#screens+1]=element\n                screens[#screens].slot=slot\n                element.activate()\n                if slot ~= \"slot1\" then icons[#icons+1]=system.getItem(element.getItemId()).iconPath end\n            elseif element.getClass()==\"LightUnit\"then \n                lights[#lights+1]=element\n                icons[#icons+1]=system.getItem(element.getItemId()).iconPath\n                element.activate()\n            end \n        end \n    end \nend\n\ntable.sort(screens, function(a,b) return a.slot < b.slot end) -- sorting screens table by slot\n\nlocal json = require(\"dkjson\")\nif lights[1] then -- Getting initial color from connected light or screen\n    ScreenVar = [[local BackgroundColor = {r=]]..lights[1].getColor()[1]..[[,g=]]..lights[1].getColor()[2]..[[,b=]]..lights[1].getColor()[3]..[[}]]\nelseif screens[2] then\n    output = json.decode(screens[2].getScriptOutput())\n    ScreenVar = [[local BackgroundColor = {r=]].. output.r ..[[,g=]].. output.g ..[[,b=]].. output.b ..[[}]]\nelse\n    ScreenVar = \"local BackgroundColor = {r=0,g=0,b=0}\"\nend\n\nlocal i = \"\"\nfor icon,path in pairs(icons) do i = i..[[\"]]..path..[[\",]] end\n\n\nlocal ScreenVar = ScreenVar .. [[\n    local Title = \"]] .. Title ..[[\"\n    local Version = ]] .. version ..[[   \n    local ScreenCount = ]] .. #screens -1 ..[[\n    local LightCount = ]] .. #lights ..[[\n    local IconSize = 64    \n    local Icons = {]] .. i ..[[}\n    \n]] \n\nscreens[1].setRenderScript(ScreenVar .. Sliders) -- setting content of control screen\n\nunit.setTimer(\"upd\",1)\nif Hide_Unit then unit.hideWidget() end\n\n\n\n", "filter": {"args": [], "signature": "onStart()", "slotKey": "-1"}, "key": "0"}, {"code": "local ScreenOutput = json.decode(screens[1].getScriptOutput())\n\nif ScreenOutput then\n    \n    if ScreenOutput.SET then\n        for i=2, #screens do screens[i].setRenderScript(\"local color = {r=\"..ScreenOutput.SET.r..\",g=\".. ScreenOutput.SET.g..\",b=\".. ScreenOutput.SET.b..\"}\"..ScreensContent) end\n        for key, light in pairs(lights) do light.setColor(ScreenOutput.SET.r,ScreenOutput.SET.g,ScreenOutput.SET.b) end\n        screens[1].clearScriptOutput()\n    end\nend\n\n\n", "filter": {"args": [{"value": "upd"}], "signature": "onTimer(tag)", "slotKey": "-1"}, "key": "1"}, {"code": "Sliders = [[\n\n\n\n\n\nlocal json = require(\"dkjson\")\nlocal small = loadFont('Play', 26)\nlocal font = loadFont('Play', 24)\n-- Get screen resolution\nlocal rx, ry = getResolution()\nlocal infoFont = loadFont('RobotoMono', 12)\nlocal medium = loadFont('Play', 20)\nlocal big = loadFont('Montserrat', 46)\nlocal layer = createLayer()\n\n\nsetNextTextAlign( layer, AlignH_Center, AlignV_Middle)\naddText( layer, big, Title, rx*0.28, ry*0.054)\n\nsetNextTextAlign( layer, AlignH_Right, AlignV_Middle)\naddText( layer, medium, \"Screens & Lights Control v\"..Version, rx*0.98, ry*0.03)\n\n----------------------------------------------------------\n------------------ FUNCTIONS -----------------------------\n----------------------------------------------------------\n\n\n\n-- Include event library\nlocal event = require('utils/event')\n--local json = require('dkjson')\n\n--# Button class definition called only at the first frame\nif not Button then\n\n    -- getEllipsis( font, text, maxWidth)\n    -- Return a shorten text string by with with ... at the end\n    function getEllipsis(font, text, maxWidth)\n        local width = getTextBounds(font, '...')\n\n        for i = 1, #text do\n            local line = getTextBounds(font, text:sub(1,i)) + width\n            if line > maxWidth then\n                return text:sub(1,i-1)..'...'\n            end\n        end\n        return text\n    end\n\n\n    Button = {}\n    Button.__index = Button\n    -- Button object constructor\n    -- .x : X component of the position\n    -- .y : Y component of the position\n    -- .width : Width of the button\n    -- .height : Height of the button\n    -- .caption : Associated text caption\n    -- .onPressed = event:new() : Event triggered when the button is pressed\n    -- .onDown = event:new() : Event triggered when the button is hold down\n    -- .onReleased = event:new() : Event triggered when the button is released\n    -- .onHover = event:new() : Event triggered when the button is hovered\n    -- .onLeave = event:new() : Event triggered when the button is leave\n    function Button:new(x, y, width, height, caption)\n        local self = {\n            x = x or 0,\n            y = y or 0,\n            w = width or 100,\n            h = height or 20,\n            caption = caption or \"\",\n            onPressed = event:new(),\n            onDown = event:new(),\n            onReleased = event:new(),\n            onEnter = event:new(),\n            onLeave = event:new(),\n            clicked = false,\n            hover = false\n        }\n\n        --Handle button events\n        function self:compute(mx,my)\n            local x, y, w, h = self.x, self.y, self.w, self.h\n\n            if mx>x and mx<x+w and my>y and my<y+h then\n                if getCursorPressed() then\n                    self.onPressed:emit(self,mx,my)\n                    self.clicked = true\n                elseif getCursorReleased() then\n                    self.onReleased:emit(self,mx,my)\n                    self.clicked = false\n                elseif getCursorDown() then\n                    self.onDown:emit(self,mx,my)\n                    self.clicked = true\n                end\n\n                if not self.hover then\n                    self.onEnter:emit(self,mx,my)\n                    self.hover = true\n\n                end\n            elseif self.hover then\n                self.onLeave:emit(self,mx,my)\n                self.hover = false\n            end\n        end\n\n        -- Draws the button on the screen using the given layer\n        function self:draw(layer, font)\n            -- Localize object data\n            local x, y, w, h = self.x, self.y, self.w, self.h\n            local min, max = self.min, self.max\n\n            --# Draw the button\n            -- Define box default strokes style\n            setDefaultStrokeColor(layer, Shape_BoxRounded, 1, 1, 1, 1)\n            setDefaultStrokeWidth(layer, Shape_BoxRounded, 0.1)\n\n            -- If the button is clicked change the background\n            if self.clicked then\n                setNextFillColor(layer, 0.1, 0.1, 0.1, 1)\n            elseif self.hover then\n                setNextFillColor(layer, 0.3, 0.3, 0.3, 1)\n            else\n                setNextFillColor(layer, 0.1, 0.1, 0.1, 1)\n            end\n            addBoxRounded(layer, x, y, w, h, 4)\n\n            -- Draw caption and value display          \n            local caption = getEllipsis(font, self.caption, w-12)\n            local font = font or nil\n\n            setNextTextAlign( layer, AlignH_Center, AlignV_Middle)\n            addText( layer, font, caption, x+0.5*w, y+0.5*h)\n        end\n\n\n        return setmetatable(self, Button)\n    end\n\nend\n\n\nlocal mx, my = getCursor()\n\n\n\n\n\n\n\n\n\n\n\n\n--# Slider class definition called only at the first frame\nif not Slider then\n\n\n    Slider = {}\n    Slider.__index = Slider\n    -- Slider object constructor\n    -- .x : X component of the position\n    -- .y : Y component of the position\n    -- .width : Width of the slider\n    -- .length : Lenght of the slider\n    -- .min : Minimum value\n    -- .max : Maximum value\n    -- .label : Associated text label\n    function Slider:new(x, y, width, length, min, max, value, label)\n        local self = {\n            x = x or 0,\n            y = y or 0,\n            l = length or 100,\n            w = width or 20,\n            min = min or 0,\n            max = max or 5,\n            ratio = 0,\n            label = label or \"\",\n            drag = false,\n            color = {1,1,1}\n        }\n        self.ratio = math.max(0, math.min(1, (value or self.min)/(self.max-self.min)))\n\n\n\n        -- Set the value of the slider\n        function self:setValue(val)\n            if type(val) == 'number' then\n                self.value = math.max(self.min, math.min(self.max, val))\n            end\n        end\n\n        -- Get the value of the slider\n        function self:getValue(val)\n            return self.ratio*(self.max - self.min) + self.min\n        end\n\n        -- Draws the slider on the screen using the given layer\n        function self:draw(layer)\n\n\n\n\n\n            -- Localize object data\n            local x, y, w, l = self.x, self.y, self.w, self.l\n            local min, max, ratio = self.min, self.max\n\n\n            -- Get cursor data (position and button state)\n            local mx, my = getCursor()\n            local pressed = getCursorPressed()\n            local released = getCursorReleased()\n\n            -- Determine if the cursor is on the bar and detect if the mouse is down\n            if (mx >= x and mx <= x+w) and (my >= y and my <= y+l) then\n\n                if pressed then self.drag = true end\n            end\n\n            -- Set the ratio based on the cursor position\n            if self.drag then\n                self.ratio = math.max(0, math.min(1, 1 - (my-y)/l))\n                if released then\n                    self.drag = false\n                end\n            end\n\n            -- Compute the slider ratio\n            local ratio = self.ratio\n            local h = ratio*(max-min)\n            local color = self.color\n            if h > 1 then \n                setNextTextAlign( layer, AlignH_Center, AlignV_Middle)\n                addText( layer, font, \"HDR\", x+0.5*w, y+l+50) \n            end\n\n            --# Draw the slider\n            -- Define box default strokes style\n            setDefaultStrokeColor(layer, Shape_BoxRounded, 1, 1, 1, 1)\n            setDefaultStrokeWidth(layer, Shape_BoxRounded, 0.1)\n\n            -- Draw the back box\n            setNextFillColor(layer, 0.1, 0.1, 0.1, 1)\n            addBoxRounded(layer, x, y, w, l, 0)\n\n            -- Draw the fill box\n            setNextFillColor(layer, color[1], color[2], color[3], 1)\n            addBoxRounded(layer, x, y+(1-ratio)*l, w, l*ratio, 0)\n\n            -- Draw the handle\n            setNextFillColor(layer, 0.5, 0.5, 0.5, 1)\n            addBoxRounded(layer, x-3, y+(1-ratio)*l -3, w+6, 6, 0)\n\n\n            -- Draw label and value display\n            --local label = self.label\n            --setNextTextAlign( layer, AlignH_Center, AlignV_Middle)\n            --addText( layer, font, label, x+0.5*w, y-14)\n\n            local display = string.format('%.2f', ratio*(max - min) + min)\n            setNextTextAlign( layer, AlignH_Center, AlignV_Middle)\n            addText( layer, font, display, x+0.5*w, y+l+18)\n        end\n\n\n        return setmetatable(self, Slider)\n    end\n\nend\n\n--------------------------------------------------------------\n------------------ INIT -----------------------------\n--------------------------------------------------------------\n\n--# Initialization called only at the first frame\nif not _init then\n    local r, g, b = BackgroundColor.r, BackgroundColor.g, BackgroundColor.b\n\n    -- Create three sliders and set their color\n    sliderRed = Slider:new(rx*0.6, ry*0.15, 80, ry*0.64, 0, 5, r, \"Red\")\n    sliderRed.color = { 1, 0, 0}\n\n    sliderGreen = Slider:new(rx*0.72, ry*0.15, 80, ry*0.64, 0, 5, g, \"Green\")\n    sliderGreen.color = { 0, 1, 0}\n\n    sliderBlue = Slider:new(rx*0.84, ry*0.15, 80, ry*0.64, 0, 5, b, \"Blue\")\n    sliderBlue.color = { 0, 0, 1}\n\n\n\n\n\n\n\n\n    -- Draw the SET buttons\n    _button_setLights = Button:new(rx*0.05+rx*0.225-100, 0.53*ry - 16, 200, 64, \"Set Color\")\n\n    --Add the action on the actions event.\n    --event:addAction( call, enabled, limit)\n\n\n    _button_setLights.onReleased:addAction( function(self,x,y)\n            setOutput(json.encode(\n                    {[\"SET\"] = {\n                            [\"r\"] = sliderRed:getValue(),\n                            [\"g\"] = sliderGreen:getValue(),\n                            [\"b\"] = sliderBlue:getValue()}})\n            )\n        end, true)\n\n\n    _init = true\nend\n\n\n--------------------------------------------------------------\n--------------------------------------------------------------\n\n\n\nlocal imagelayer = createLayer()\n\n\n\n\n\n------------\n-- LIGHTS --\n------------\n\nlocal x = rx*0.08\nfor i, line in ipairs(Icons) do\n    local y = ry*0.15\n    if i > 5 then\n        y = ry*0.26 \n    end\n    if i == 6 then x = rx*0.08 end\n    image = loadImage(line)\n    addImage(imagelayer, image, x,y, IconSize, IconSize)\n    x = x + IconSize + 15\nend\n\n\n-- Box background\nsetNextFillColor( layer, 0.05, 0.05, 0.05, 1)\naddBoxRounded( layer, rx*0.05, ry*0.11, rx*0.45, ry*0.3, 16)\n\n-- Draw buttons\n_button_setLights:compute(mx,my)\n_button_setLights:draw( layer, medium)\n\n\n\n\n\n\n\n\n\n-- Draw a box behind the sliders\nsetNextFillColor( layer, 0.05, 0.05, 0.05, 1)\naddBoxRounded( layer, rx*0.55, ry*0.11, rx*0.415, ry*0.85, 16)\n\n\n-- Draw sliders\nsliderRed:draw( layer)\nsliderGreen:draw( layer)\nsliderBlue:draw( layer)\n\n\n\n--# Rendering\n-- Set the background color based on sliders value\n-- Box background\nsetNextFillColor( layer, sliderRed:getValue(),  sliderGreen:getValue(), sliderBlue:getValue(), 1)\naddBoxRounded( layer, rx*0.05, ry*0.66, rx*0.45, ry*0.3, 16)\n\n\n\n-- Request a run at each frame\nrequestAnimationFrame(1)\n\n\n\n\n]]", "filter": {"args": [], "signature": "onStart()", "slotKey": "-5"}, "key": "2"}, {"code": "ScreensContent = [[\n\n\nlocal json = require(\"dkjson\")\nlocal layer = createLayer()\nlocal rx,ry=getResolution() \n\nfor i=0, 1, 0.03 do\n    setNextStrokeColor(layer,0, 0, 0,1)\n    addLine(layer,0,ry*i,rx,ry*i)\nend\n\n\n    setBackgroundColor(color.r, color.g, color.b)\nsetOutput(json.encode(color))\n\n]]", "filter": {"args": [], "signature": "onStart()", "slotKey": "-5"}, "key": "3"}], "methods": [], "events": []}
